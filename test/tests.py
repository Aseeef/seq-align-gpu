#!/usr/bin/env python3

"""
This script was generated by GPT o4 for validating the correctness of my code.
Prompts used: https://chatgpt.com/share/680dee2a-0b2c-800f-a7eb-0ebf92dfe9b6
"""

import argparse
import subprocess
import re
import sys

def parse_fasta(path):
    """
    Parse a FASTA file; returns a list of (header, sequence) tuples.
    """
    seqs = []
    header = None
    lines = []
    with open(path) as f:
        for l in f:
            l = l.rstrip()
            if not l:
                continue
            if l.startswith('>'):
                if header is not None:
                    seqs.append((header, ''.join(lines)))
                header = l[1:].strip()
                lines = []
            else:
                lines.append(l)
        if header is not None:
            seqs.append((header, ''.join(lines)))
    return seqs

def extract_modified_scores(mod_cmd, matrix, query, db):
    """
    Run the modified smith_waterman2 tool once and parse its output
    for lines like:
      Entry #557023:
      score: 16
    Returns dict {entry_index: score_int}.
    """
    proc = subprocess.run(
        [mod_cmd, '--substitution_matrix', matrix, '--files', query, db],
        stdout=subprocess.PIPE,
        stderr=subprocess.PIPE,
        text=True,
        check=True
    )
    out = proc.stdout
    entry_rx = re.compile(r'Entry\s+#(\d+):\s*score:\s*([+-]?\d+)', re.IGNORECASE)
    d = {}
    for m in entry_rx.finditer(out):
        d[int(m.group(1))] = int(m.group(2))
    return d

def extract_first_score_from_original(orig_cmd, matrix, seq1, seq2):
    """
    Run the original smith_waterman tool on two raw sequences,
    capture its stdout, and return the first integer after 'score:'.
    """
    proc = subprocess.run(
        [orig_cmd, '--substitution_matrix', matrix, seq1, seq2],
        stdout=subprocess.PIPE,
        stderr=subprocess.PIPE,
        text=True,
        check=True
    )
    m = re.search(r'score:\s*([+-]?\d+)', proc.stdout)
    if not m:
        raise ValueError("No 'score:' line found in original SW output")
    return int(m.group(1))

def main():
    p = argparse.ArgumentParser(
        description="Compare modified vs. original Smith-Waterman"
    )
    p.add_argument('query', help='Path to query FASTA (1 sequence)')
    p.add_argument('database', help='Path to DB FASTA (â‰¥1 sequence)')
    p.add_argument('matrix', help='Substitution matrix file')
    p.add_argument(
        '--modified_cmd',
        default='smith_waterman2',
        help='Name/path of your modified SW executable'
    )
    p.add_argument(
        '--original_cmd',
        default='smith_waterman',
        help='Name/path of the original SW executable'
    )
    args = p.parse_args()

    # load query
    q_list = parse_fasta(args.query)
    if len(q_list) != 1:
        sys.exit(f"Error: expected 1 sequence in query FASTA, found {len(q_list)}")
    _, q_seq = q_list[0]

    # load database
    db_list = parse_fasta(args.database)
    if not db_list:
        sys.exit("Error: no sequences found in database FASTA")

    # 1) run modified tool once
    try:
        mod_scores = extract_modified_scores(
            args.modified_cmd, args.matrix, args.query, args.database
        )
    except (FileNotFoundError, subprocess.CalledProcessError) as e:
        sys.exit(f"Error running modified tool: {e}")

    # 2) compare against original for each entry index
    for idx, (hdr, db_seq) in enumerate(db_list):
        if idx not in mod_scores:
            sys.exit(f"Missing modified score for Entry #{idx}")
        try:
            orig_score = extract_first_score_from_original(
                args.original_cmd, args.matrix, q_seq, db_seq
            )
        except (FileNotFoundError, subprocess.CalledProcessError, ValueError) as e:
            sys.exit(f"Error running original SW on entry #{idx}: {e}")

        if orig_score != mod_scores[idx]:
            # print full FASTA record, sequence, and entry id
            print(f"> {hdr}\n{db_seq}", file=sys.stderr)
            print(f"Sequence: {db_seq}", file=sys.stderr)
            print(f"Entry ID: {idx}", file=sys.stderr)
            print(f"Modified score = {mod_scores[idx]}, original score = {orig_score}", file=sys.stderr)
            sys.exit(1)

    print("All scores match between modified and original tools.")
    sys.exit(0)

if __name__ == '__main__':
    main()
